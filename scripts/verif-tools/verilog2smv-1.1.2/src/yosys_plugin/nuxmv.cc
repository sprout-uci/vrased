//
// Author: Ahmed Irfan <irfan@fbk.eu>
//
// This file is part of verilog2smv.
// Copyright (C) 2015 Fondazione Bruno Kessler.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
//

#include "nuxmv.h"
#include <ctime>

const std::string VERILOG2SMV_VERSION = "verilog2smv-1.1.2";

static std::string banner_str()
{
  time_t now = time(0);
  char* dt = ctime(&now);
  std::string out = stringf("-- Generated by %s on %s", 
                            VERILOG2SMV_VERSION.c_str(), dt);
  out += stringf("-- Using %s\n", yosys_version_str);
  return out;
}

TranslateModule::TranslateModule(std::ostream &f, RTLIL::Module* module) :
  f(f), module(module)
{ 
  output_signal = false;
  sigmap = SigMap(module);
  ts.modulename = module->name.str();
  //unary cells
  cell_type_translation["$not"] = "!";
  cell_type_translation["$neg"] = "!";
  //binary cells
  cell_type_translation["$and"] = "&";
  cell_type_translation["$or"] = "|";
  cell_type_translation["$xor"] = "xor";
  cell_type_translation["$xnor"] = "xnor";
  cell_type_translation["$shr"] = ">>";
  cell_type_translation["$shl"] = "<<";
  cell_type_translation["$sshr"] = ">>"; // arithmetic shift right
  cell_type_translation["$sshl"] = "<<";
  cell_type_translation["$shift"] = ">>"; // not sure if it is similar to right shift // raise error if signed
  cell_type_translation["$shiftx"] = ">>"; // not sure if it is similar to right shift // raise error if signed
  cell_type_translation["$lt"] = "<";
  cell_type_translation["$le"] = "<=";
  cell_type_translation["$gt"] = ">";
  cell_type_translation["$ge"] = ">=";
  cell_type_translation["$eq"] = "=";
  cell_type_translation["$eqx"] = "=";
  cell_type_translation["$ne"] = "!=";
  cell_type_translation["$nex"] = "!=";
  cell_type_translation["$add"] = "+";
  cell_type_translation["$sub"] = "-";
  cell_type_translation["$mul"] = "*";
  cell_type_translation["$mod"] = "mod";
  cell_type_translation["$div"] = "/";
  cell_type_translation["$concat"] = "::";
  //ternary cell
  cell_type_translation["$mux"] = "?";
  
}

void TranslateModule::Collect()
{
  setup();
  CollectVar();
  CollectIvar();
  CollectInit();
  CollectTrans();
  CollectAssgn();
  CollectInvar();
  CollectOutput();
}

void TranslateModule::Dump()
{
  f << banner_str().c_str() << "\n";

  f << "MODULE " << RTLIL::unescape_id(module->name) << "\n";

  if (ts.ivarlst.size() > 0) {
    f << "\n -- input vars --\nIVAR\n";
    dump_ts_lst(ts.ivarlst, "  ", "\n");
  }

  if (ts.varlst.size() > 0) {
    f << "\n -- state vars --\nVAR\n";
    dump_ts_lst(ts.varlst, "  ", "\n");
  }

  if (ts.undrvarlst.size() > 0) {
    f << "\n -- undriven wires as vars --\nVAR\n";
    dump_ts_lst(ts.undrvarlst, "  ", "\n");
  }

  if (ts.deflst.size() > 0) {
    f << "\nDEFINE\n";
    dump_ts_lst(ts.deflst, "  ", "\n");
  }

  f << "\n -- initialization --\n"; //init
  if (ts.initlst.size() > 0) {
    dump_ts_lst(ts.initlst, "INIT ", "\n");
  }

  f << "\n -- transition --\n"; //trans
  if (ts.translst.size() > 0) {
    dump_ts_lst(ts.translst, "TRANS ", "\n");
  }

  if (ts.assgnlst.size() > 0) {
    f << "\n -- functional assignments --";
    f << "\nASSIGN\n";
    dump_ts_lst(ts.assgnlst, "  ", "\n");
  }

  if (ts.invarlst.size() > 0) {
    f << "\n -- invariant properties -- \n";
    dump_ts_lst(ts.invarlst, "INVARSPEC ", "\n");
  }

  if (ts.outputlst.size() > 0) {
    f << "\n -- output signals -- \n";
    f << "DEFINE\n";
    dump_ts_lst(ts.outputlst, "  ", "\n");
  }
}

void TranslateModule::CollectIvar()
{
  for (auto &wire_it : module->wires_) {
    RTLIL::Wire* wire = wire_it.second;
    if (wire->port_input) {
      ts.ivarlst.push_back(get_wire_decl(wire));
      save_wire_cxt(wire);
      ref.set(wire, stringf("\"%s\"", RTLIL::unescape_id(wire->name).c_str()));
    }
  }
}

void TranslateModule::CollectVar()
{
  for (auto it = module->cells_.begin(); it != module->cells_.end(); ++it) {
    RTLIL::Cell* cell = it->second;
    if (is_cell_register(cell)) {
      const RTLIL::SigSpec* s = get_cell_output(cell);
	
      for (auto &c : s->chunks()) {
	RTLIL::Wire* wire = c.wire;
	ts.varlst.push_back(get_wire_decl(wire));
	save_wire_cxt(wire);
	ref.set(wire, stringf("\"%s\"", RTLIL::unescape_id(wire->name).c_str()));
      }
    }
  }

  for (auto mem_it = module->memories.begin();
       mem_it != module->memories.end();
       ++mem_it) {
    ts.varlst.push_back(get_memory_decl(mem_it->second));
    ref.set(mem_it->second, stringf("\"%s\"",
				    RTLIL::unescape_id(mem_it->second->name).c_str()));
  }
}

void TranslateModule::CollectInitRegister()
{
  for (auto &it : module->wires_) {
    RTLIL::Wire* wire = it.second;
    
    if (wire->attributes.count("\\init")) {
      RTLIL::SigSpec sig = sigmap(wire);
      std::string sig_expr;
      bool sig_cxt = false;

      if (sig.is_wire()) {
	RTLIL::Wire* state_wire = sig.as_wire();
	log_assert(state_wire->width == wire->width);
	if (ref.has(state_wire)) {
	  sig_expr = ref.get(state_wire);
	  log_assert(!sig_expr.empty());
	  sig_cxt = cxt.get(state_wire);
	} else {
	  // wire is not required in the design
	  continue;
	}
	//log_assert(!(wire->port_output));
      } else {
	sig_expr = get_sig_expr(&sig, true);
	sig_cxt = true;
      }
      
      Const val = wire->attributes.at("\\init");
      val.bits.resize(wire->width);

      std::string expr = mk_new_def();
      if (sig_cxt) {
        ts.deflst.push_back(stringf("%s := (%s = 0ub%d_%s);",
                                    expr.c_str(),
                                    sig_expr.c_str(),
                                    wire->width,
                                    val.as_string().c_str()));
      } else {
        bool bval = val.as_bool();
        ts.deflst.push_back(stringf("%s := %s (%s);",
                                    expr.c_str(),
                                    bval ? "" : "!",
                                    sig_expr.c_str()));
      }
      ts.initlst.push_back(expr);
    }
  }
}

void TranslateModule::CollectInitMemory()
{
  std::map<RTLIL::IdString, std::vector<RTLIL::Cell*>> mem_init_cells_map;

  for (auto mem_it = module->memories.begin();
       mem_it != module->memories.end();
       ++mem_it) {
    RTLIL::IdString mem_name = mem_it->second->name;
    mem_init_cells_map[mem_name] = std::vector<RTLIL::Cell*>();
  }

  for (auto cell_it = module->cells_.begin();
       cell_it != module->cells_.end();
       ++cell_it) {
    RTLIL::Cell* cell = cell_it->second;

    if (cell->type == "$meminit") {
      std::string str = cell->parameters.at("\\MEMID").decode_string();
      RTLIL::IdString cell_mem_name = module->memories.at(str.c_str())->name;
      mem_init_cells_map[cell_mem_name].push_back(cell);
    }
  }

  for (auto mem_it = module->memories.begin();
       mem_it != module->memories.end();
       ++mem_it) {
    std::string mem_str = get_mem_init_expr(mem_it->second, mem_init_cells_map);
    if (!mem_str.empty()) {
      std::string expr = sav_def_expr(stringf("(%s = %s)",
                                              ref.get(mem_it->second).c_str(),
                                              mem_str.c_str()));
      ts.initlst.push_back(expr);
    }
  }
}

void TranslateModule::CollectInit()
{
  CollectInitRegister();
  CollectInitMemory();
}

void TranslateModule::CollectMemNext(RTLIL::Memory* mem)
{
  typedef std::pair<int, RTLIL::Cell*> prior_memwr;
  struct prior_ {
    bool operator() (prior_memwr a, prior_memwr b) {
      return (a.first < b.first);
    } 
  };

  std::set<prior_memwr, prior_> memwrset;
  std::string out;
  for (auto it = module->cells_.begin(); it != module->cells_.end(); ++it) {
    RTLIL::Cell* cell = it->second;
    if (cell->type == "$memwr") {
      if (cell->parameters.at("\\MEMID").decode_string() == mem->name.str()) {
	int p = cell->parameters.at("\\PRIORITY").as_int();
	memwrset.insert(std::make_pair(p, cell));
      }
    }
  }

  for (auto it = memwrset.rbegin(); it != memwrset.rend(); ++it) {
    RTLIL::Cell* cell = it->second;
    if (cell->parameters.at("\\CLK_ENABLE").as_bool() == false)
      log_error("Run memory_dff -wr_only\n");
    std::string clk = get_sig_expr_as_bool(&cell->getPort("\\CLK"));
    bool pol = cell->parameters.at("\\CLK_POLARITY").as_bool();
    std::string en = get_sig_expr_as_bool(&cell->getPort("\\EN"));
    std::string a = get_sig_expr_as_word(&cell->getPort("\\ADDR"));
    std::string d = get_sig_expr_as_word(&cell->getPort("\\DATA"));
    std::string cond = sav_def_expr(stringf("%s (%s)", pol ? "":"!",
					    clk.c_str()));
    cond = sav_def_expr(stringf("(%s & %s)", 
				en.c_str(), cond.c_str()));
    if (out.empty()) {
      out = stringf("(%s ? WRITE(%s, %s, %s) : %s)",
		    cond.c_str(), ref.get(mem).c_str(),
		    a.c_str(), d.c_str(),
		    ref.get(mem).c_str());
    } else {
      out = stringf("(%s ? WRITE(%s, %s, %s) : %s)",
		    cond.c_str(), out.c_str(),
		    a.c_str(), d.c_str(), out.c_str());
    }
  }

  if (!(out.empty())) {
    next[ref.get(mem)] = out;
  }
}

void TranslateModule::CollectRegNext()
{
  for (auto it = module->cells_.begin(); it != module->cells_.end(); ++it) {
    RTLIL::Cell* cell = it->second;
    if (is_cell_register(cell)) {
      int ow = cell->parameters.at("\\WIDTH").as_int();
      std::string cond = cell->type == "$dlatch" ?
	get_sig_expr_as_bool(&cell->getPort("\\EN")) :
	get_sig_expr_as_bool(&cell->getPort("\\CLK"));
      bool pol = cell->type == "$dlatch" ?
	cell->parameters.at("\\EN_POLARITY").as_bool() :
	cell->parameters.at("\\CLK_POLARITY").as_bool();
      std::string v = get_sig_expr_as_word(&cell->getPort("\\D"));
      const RTLIL::SigSpec* cell_output = get_cell_output(cell);
      unsigned start = 0;
      for (auto it = cell_output->chunks().begin();
	   it != cell_output->chunks().end();
	   ++it) {
	ow = it->width;
	log_assert( ow == it->wire->width);
	std::string reg = ref.get(it->wire);
	bool reg_cxt = cxt.get(it->wire);
	std::string slice = v;
	if (cell_output->chunks().size() > 1) {
	  start += ow;
	  slice = mk_slice(v, start - 1, ow);
	}
	slice = mk_compatible(slice, reg_cxt, true, ow, ow);
	if (cell->type == "$dffsr") {
	  std::string sync_reset = get_sig_expr_as_bool(&cell->getPort("\\CLR"));
	  bool sync_reset_pol = cell->parameters.at("\\CLR_POLARITY").as_bool();
	  std::string sync_reset_val = get_sig_expr(&cell->getPort("\\SET"), reg_cxt);
	  bool sync_reset_val_pol = cell->parameters.at("\\SET_PORLARITY").as_bool();
	  slice = sav_def_expr(stringf("(%s (%s) ? %s (%s) : %s)",
				       sync_reset_pol ? "":"!",
				       sync_reset.c_str(),
				       sync_reset_val_pol ? "":"!",
				       sync_reset_val.c_str(),
				       slice.c_str()));
	}
	std::string out = sav_def_expr(stringf("(%s (%s) ? %s : %s)",
					       pol ? "":"!", cond.c_str(),
					       slice.c_str(),
					       reg.c_str()));
	if (cell->type == "$adff") {
	  std::string async_reset = get_sig_expr_as_bool(&cell->getPort("\\ARST"));
	  bool async_reset_pol = cell->parameters.at("\\ARST_POLARITY").as_bool();
	  std::string async_reset_value = 
	    get_const_expr(&cell->parameters.at("\\ARST_VALUE"), ow, 0);
	  out = sav_def_expr(stringf("(%s (%s) ? %s : %s)",
				     async_reset_pol ? "":"!", async_reset.c_str(),
				     async_reset_value.c_str(),
				     out.c_str()));
	}
	next[reg] = out;
      }
    }
  }
}

void TranslateModule::CollectNext()
{
  CollectRegNext();
  for (auto mem_it = module->memories.begin();
       mem_it != module->memories.end(); ++mem_it) {
    CollectMemNext(&(*mem_it->second));
  }
}

void TranslateModule::CollectTrans()
{
  CollectNext();
  for (auto it = next.begin(); it != next.end(); ++it) {
    std::string expr = stringf("next(%s) = %s", it->first.c_str(),
			       it->second.c_str());
    ts.translst.push_back(expr);
  }
}

void TranslateModule::CollectAssgn()
{
    
}

void TranslateModule::CollectInvar()
{
  for (auto &it : module->cells_) {
    RTLIL::Cell* cell = it.second;
    if (cell->type == "$assert") {
      std::string out = get_cell_expr(cell, false);
      std::string name = cell->attributes.at("\\src").decode_string();
      if (!(name.empty())) {
        out = " NAME \"" + name + "\"" + " := " + out + ";";
      }
      ts.invarlst.push_back(out);
    }
  }
  for (auto &it : module->wires_) {
    RTLIL::Wire* wire = it.second;
    if (wire->name.str().find("safety") != std::string::npos) {
      std::string out = get_wire_expr(wire, false);
      std::string name = wire->attributes.at("\\src").decode_string();
      if (!(name.empty())) {
        out = " NAME \"" + name + "\"" + " := " + out + ";";
      }
      ts.ivarlst.push_back(out);
    }
  }
}

void TranslateModule::CollectOutput()
{
  if (output_signal) {
    for (auto &wire_it : module->wires_) {
      RTLIL::Wire* wire = wire_it.second;
      if (wire->port_output) {
        std::string out = stringf("\"%s\"",
                                  RTLIL::unescape_id(wire->name).c_str());
        std::string tmp = get_wire_expr(wire, !is_wire_bool(wire));
        if (out != tmp) {
          out += " := " + tmp + ";";
        }
        else {
          out = "-- " + out;
        }
        ts.outputlst.push_back(out);
      }
    }
  }
}

const RTLIL::SigSpec* TranslateModule::get_cell_output(const RTLIL::Cell* cell)
{
  const RTLIL::SigSpec* output_sig = nullptr;
  if (cell->type == "$memrd") {
    output_sig = &cell->getPort("\\DATA");
  } else if (cell->type == "$memwr" ||
	     cell->type == "$assert" ||
	     cell->type == "$meminit") {
    //no output                                                                                                  
  } else if (cell->type == "$dff" ||
	     cell->type == "$adff" ||
	     cell->type == "$dffsr" ||
	     cell->type == "$dlatch") {
    output_sig = &cell->getPort("\\Q");
  } else {
    output_sig = &cell->getPort("\\Y");
  }
  return output_sig;
}

std::string TranslateModule::get_mem_init_expr(RTLIL::Memory* mem,	    
      std::map<RTLIL::IdString, std::vector<RTLIL::Cell*>> mem_init_cells_map)
{
  RTLIL::IdString mem_name = mem->name;
  if (mem_init_cells_map[mem_name].size()==0) {
    return std::string();
  }

  std::unordered_map<std::string, unsigned int> mem_values;
  for (unsigned i=0; i < mem_init_cells_map[mem_name].size(); ++i) {
    RTLIL::Cell *cell = mem_init_cells_map[mem_name][i];
    int elem_width = cell->parameters.at("\\WIDTH").as_int();
    int num_elem = cell->parameters.at("\\WORDS").as_int();
    RTLIL::SigSpec initval = cell->getPort("\\DATA");
    log_assert(initval.is_fully_const());
    RTLIL::Const initval_const = initval.as_const();

    for (int j = 0; j < num_elem; ++j) {
      std::string data = initval_const.extract(j * elem_width,
					       elem_width).as_string();
      auto mem_values_it = mem_values.find(data);

      if (mem_values_it != mem_values.end()) {
	mem_values_it->second++;
      } else {
	mem_values[data] = 1;
      }
    }
  }

  auto base_value = std::max_element(mem_values.begin(), mem_values.end(),
				     [](const pair<std::string, unsigned>& p1,
					const pair<std::string, unsigned>& p2) {
				       return p1.second < p2.second; });
  std::string mem_str = stringf("CONSTARRAY(typeof(%s), 0ub%zu_%s)",
				ref.get(mem_name).c_str(),
				base_value->first.size(),
				base_value->first.c_str());

  for (unsigned long i=0; i < mem_init_cells_map[mem_name].size(); ++i) {
    RTLIL::Cell *cell = mem_init_cells_map[mem_name][i];
    int abits = cell->parameters.at("\\ABITS").as_int();
    int elem_width = cell->parameters.at("\\WIDTH").as_int();
    RTLIL::SigSpec initval = cell->getPort("\\DATA");
    log_assert(initval.is_fully_const());
    RTLIL::Const initval_const = initval.as_const();

    for (int k = 0; (k * elem_width) < initval_const.size(); k = k + 1) {
      std::string data = initval_const.extract(k * elem_width,
					       elem_width).as_string();

      if (data != base_value->first) {
	std::string address = stringf("0ud%d_%d", abits, k);
	mem_str = stringf("WRITE(%s, %s, 0ub%zu_%s)",
			  mem_str.c_str(),
			  address.c_str(),
			  data.size(),
			  data.c_str());
      }
    }
  }

  return mem_str;
}

std::string TranslateModule::mk_compatible(std::string e, bool o_cxt, bool i_cxt, 
					   int o_width, int i_width)
{
  std::string out = e;
  if (o_cxt) {
    if (!(i_cxt)) {
      log_assert(i_width == 1);
      out = mk_word1(out);
    }
    if (i_width != o_width) {
      out = mk_resize(out, o_width);
    }
  } else {
    //log_assert(o_width == 1);
    if (i_cxt) {
      if (i_width > 1) {
	out = mk_resize(out, 1);
      }
      out = mk_bool(out);
    }
  }
  return out;
}

std::string TranslateModule::get_wire_decl(const RTLIL::Wire* wire)
{
  if (is_wire_bool(wire)) {
    return stringf("\"%s\" : boolean;",
		   RTLIL::unescape_id(wire->name).c_str());
  } else {
    log_assert(wire->width > 1);
    return stringf("\"%s\" : word[%d];",
		   RTLIL::unescape_id(wire->name).c_str(), wire->width);
  }
}

std::string TranslateModule::get_memory_decl(const RTLIL::Memory* mem)
{
  int address_bits = ceil(log(mem->size)/log(2));
  log_assert(address_bits > 0);

  return stringf("\"%s\" : array word[%d] of word[%d];",
		 RTLIL::unescape_id(mem->name).c_str(),
		 address_bits, mem->width);
}

std::string TranslateModule::get_wire_expr(RTLIL::Wire* wire, bool bv)
{
  log("writing wire : %s \n", wire->name.str().c_str());
  if (ref.has(wire)) {
    return ref.get(wire);
  } else if (inter_wire_map.find(wire->name) == inter_wire_map.end()) {
    std::string wire_expr;
    RTLIL::SigSpec sig = sigmap(wire);
    if (sig == RTLIL::SigSpec(wire) ) {
      log("found undriven wire\n");
      ts.undrvarlst.push_back(get_wire_decl(wire));
      save_wire_cxt(wire);
      wire_expr = stringf("\"%s\"",
                          RTLIL::unescape_id(wire->name).c_str());
    }
    else {
      wire_expr = get_sig_expr(&sig, bv);
      cxt.set(wire, bv);
    }
    ref.set(wire, wire_expr);
    return wire_expr;
  } else {
    std::set<WireInfo, WireInfoOrder>& dep_set = inter_wire_map.at(wire->name);
    std::string wire_expr;
    bool wire_cxt;
    for (auto dep_set_it = dep_set.begin();
	 dep_set_it != dep_set.end();
	 ++dep_set_it) {
      RTLIL::IdString cell_id = dep_set_it->cell_name;
      RTLIL::Cell* cell = module->cells_.at(cell_id);
      const RTLIL::SigSpec* cell_output = get_cell_output(cell);
      std::string cell_expr = get_cell_expr(cell, bv);

      wire_cxt = cxt.get(cell);

      if (dep_set.size() == 1 && wire->width >= cell_output->size()) {
	if(wire->width > cell_output->size()) {
	  if (!(cxt.get(cell))) {
	    cell_expr = mk_word1(cell_expr);
	  }
	  cell_expr = mk_resize(cell_expr, wire->width);
	  wire_cxt = true;
	}
	wire_expr = cell_expr;
	break;
      } else {
	std::string prev_wire_expr; //previously dumped wire line
	int start_bit=0;
	for (auto it = cell_output->chunks().begin();
	     it != cell_output->chunks().end();
	     ++it) {
	  start_bit += it->width;
	  if (it->wire->name == wire->name) {
	    prev_wire_expr = wire_expr;
	    wire_expr = mk_slice(cell_expr,
				 start_bit - 1,
				 it->width);
	    if (!prev_wire_expr.empty()) {
	      wire_expr = mk_concat(wire_expr, prev_wire_expr);
	      wire_cxt = true;
	    }
	  }
	}
      }
    }

    log_assert(wire_cxt == bv);
    ref.set(wire, wire_expr);
    cxt.set(wire, wire_cxt);
    return wire_expr;
  }
}

std::string TranslateModule::get_const_expr(const RTLIL::Const* c, int width, int offset)
{
  log("writing const \n");
  std::string out;
  if((c->flags & RTLIL::CONST_FLAG_STRING) == 0) {
    if(width<0)
      width = c->bits.size() - offset;

    std::string data_str = c->as_string();
    data_str = data_str.substr(offset, width);
    for (size_t i = 0; i < data_str.size(); ++i) {
      if (!(data_str[i] == '0' || data_str[i] == '1')) {
	data_str[i] = '0';
      }
    }
    out = stringf("0ub%d_%s", width, data_str.c_str());
  } else {
    log("writing const error\n");		
    log_abort();
  }
  return out;
}

std::string TranslateModule::get_chunk_expr(const RTLIL::SigChunk* chunk, bool bv)
{
  log("writing sigchunk\n");
  std::string out;

  if (chunk->wire == NULL) {
    RTLIL::Const data_const(chunk->data);
    out = get_const_expr(&data_const, chunk->width, chunk->offset);
  } else if (chunk->width == chunk->wire->width && chunk->offset == 0) {
    out = get_wire_expr(chunk->wire, bv);
  } else {
    std::string wire_expr = get_wire_expr(chunk->wire, true);
    log_assert(!wire_expr.empty());

    if (!(cxt.get(chunk->wire))) {
      wire_expr = mk_word1(wire_expr);
    }

    out = mk_new_def();
    ts.deflst.push_back(stringf("%s := %s[%d:%d];",
				out.c_str(),
				wire_expr.c_str(),
				chunk->width + chunk->offset - 1,
				chunk->offset));
  }
  return out;
}

std::string TranslateModule::get_sig_expr(const RTLIL::SigSpec* sig, bool bv)
{
  log("Writing sig\n");
  RTLIL::SigSpec s = sigmap(*sig);
  std::string out;
  bool sig_cxt;
  if (ref.has(s)) {
    return ref.get(s);
  } else if (s.is_chunk()) {
    const RTLIL::SigChunk *c = &s.chunks().front();
    out = get_chunk_expr(c, bv);
    sig_cxt = cxt.get(c);
  } else {
    std::string a, b;
    const RTLIL::SigChunk *c = &s.chunks().front();
    b = get_chunk_expr(c, true);
    sig_cxt = cxt.get(c);
    log_assert(!(b.empty()));

    if ((c->wire != NULL) && !(cxt.get(c->wire))) {
      b = mk_word1(b);
    }

    for (auto it = s.chunks().begin() + 1; it != s.chunks().end(); ++it) {
      c = &(*it);
      a = get_chunk_expr(c, true);
      if ((c->wire != NULL) && !(cxt.get(c->wire))) {
	a = mk_word1(a);
      }
      b = mk_concat(a, b);
      sig_cxt = true;
    }
    out = b;
  }
  ref.set(s, out);
  cxt.set(s, sig_cxt);
  return out;
}

std::string TranslateModule::get_sig_expr_as_bool(const RTLIL::SigSpec* sig)
{
  RTLIL::SigSpec s = sigmap(*sig);
  std::string sig_expr = get_sig_expr(&s, false);
  if (cxt.get(s)) {
    if (sig->size() > 1) {
      sig_expr = mk_resize(sig_expr, 1);
    }
    sig_expr = mk_bool(sig_expr);
  }
  return sig_expr;
}

std::string TranslateModule::get_sig_expr_as_word(const RTLIL::SigSpec* sig)
{
  RTLIL::SigSpec s = sigmap(*sig);
  std::string sig_expr = get_sig_expr(&s, true);
  log_assert(!(sig_expr.empty()));
  if (!(cxt.get(s))) {
    sig_expr = mk_word1(sig_expr);
  }
  return sig_expr;
}

/* need to take care about size of the expression according to the
   standard, while doing the cell translation

   A self-determined expression is one where the bit length of the
   expression is solely determined by the expression itselfâ€”for
   example, an expression representing a delay value.

   A context-determined expression is one where the bit length of the
   expression is determined by the bit length of the expression and by
   the fact that it is part of another expression. For example, the
   bit size of the right- hand expression of an assignment depends on
   itself and the size of the left-hand side.

   here is the flow
   - sign cast
   - resize if required again
 */
std::string TranslateModule::get_cell_expr(const RTLIL::Cell* cell, bool bv)
{
  log("Writing cell : %s \n", cell->name.str().c_str());
  bool cell_cxt;
  std::string out;
  if (ref.has(cell)) {
    return ref.get(cell);
  } else if (cell->type == "$assert") {

    log_assert(!bv);
    std::string prop = get_sig_expr_as_bool(&cell->getPort("\\A"));
    std::string en = get_sig_expr_as_bool(&cell->getPort("\\EN"));
    out = sav_def_expr(stringf("(%s -> %s)", en.c_str(), prop.c_str()));
    cell_cxt = false;

  } else if (cell->type == "$neg" ||
	     cell->type == "$pos" ||
	     cell->type == "$not") {
    /* context determination for size */
    std::string a = get_sig_expr_as_word(&cell->getPort("\\A"));
    int aw = cell->parameters.at("\\A_WIDTH").as_int();
    int ow = cell->parameters.at("\\Y_WIDTH").as_int();
    bool a_signed = cell->parameters.at("\\A_SIGNED").as_bool();
    if (a_signed) { 
      a = mk_signed(a);
    }
    if (aw < ow) {
      a = mk_resize(a, ow);
      aw = ow;
    }
    out = sav_def_expr(stringf("%s (%s)",
			       cell_type_translation[cell->type.str()].c_str(),
			       a.c_str()));
    if (a_signed) {
      out = mk_compatible(out, true, true, ow, aw);
      out = mk_unsigned(out);
      out = mk_compatible(out, bv, true, ow, ow);
    } else {
      out = mk_compatible(out, bv, true, ow, aw);
    }
    cell_cxt = bv;

  } else if (cell->type == "$reduce_and" ||
	     cell->type == "$reduce_or" ||
	     cell->type == "$reduce_bool" ||
	     cell->type == "$logic_not" ||
	     cell->type == "$reduce_xor" ||
	     cell->type == "$reduce_xnor") {
    /* All operands are self-determined */
    std::string a = get_sig_expr_as_word(&cell->getPort("\\A"));
    int aw = cell->parameters.at("\\A_WIDTH").as_int();
    int ow = cell->parameters.at("\\Y_WIDTH").as_int();
    if (cell->type == "$reduce_and") {
      out = sav_def_expr(stringf("%s = %s 0ud%d_0",
				 a.c_str(),
				 cell_type_translation["$not"].c_str(),
				 aw));
    } else if (cell->type == "$reduce_or" || cell->type == "$reduce_bool") {
      out = sav_def_expr(stringf("%s > 0ud%d_0", a.c_str(), aw));
    } else if (cell->type == "$logic_not") {
      out = sav_def_expr(stringf("%s = 0ud%d_0", a.c_str(), aw));
    } else if (cell->type == "$reduce_xor" || cell->type == "$reduce_xnor") {
      std::string t = (cell->type == "$reduce_xor") ? 
	cell_type_translation["$xor"] : cell_type_translation["$xnor"];
      log_assert(aw > 1);
      int i = aw - 1;
      out = mk_slice(a, i, 1);
      for (--i; i >= 0; --i) {
	std::string temp = mk_slice(a, i, 1);
	out = sav_def_expr(stringf("(%s %s %s)", temp.c_str(),
				   t.c_str(), out.c_str())); 
      }
      out = sav_def_expr(stringf("bool(%s)", out.c_str()));
    }
    out = mk_compatible(out, bv, false, ow, 1);
    cell_cxt = bv;

  } else if (cell->type == "$and" ||
	     cell->type == "$or" ||
	     cell->type == "$xor" ||
	     cell->type == "$xnor" ||
	     cell->type == "$add" ||
	     cell->type == "$sub" ||
	     cell->type == "$mul" ||
	     cell->type == "$div" ||
	     cell->type == "$mod") {
    /* context determination for size */
    std::string a = get_sig_expr_as_word(&cell->getPort("\\A"));
    std::string b = get_sig_expr_as_word(&cell->getPort("\\B"));
    int aw = cell->parameters.at("\\A_WIDTH").as_int();
    int bw = cell->parameters.at("\\B_WIDTH").as_int();
    int ow = cell->parameters.at("\\Y_WIDTH").as_int();
    bool a_signed = cell->parameters.at("\\A_SIGNED").as_bool();
    bool b_signed = cell->parameters.at("\\B_SIGNED").as_bool(); 
    log_assert(a_signed == b_signed);
    //      log_assert(!(a_signed));
    if (a_signed) {
      a = mk_signed(a);
      b = mk_signed(b);
    }
    if (aw < ow) {
      a = mk_resize(a, ow);
      aw = ow;
    }
    if (aw < bw) {
      a = mk_resize(a, bw);
      aw = bw;
    }
    if (bw < aw) {
      b = mk_resize(b, aw);
      bw = aw;
    }
    out = sav_def_expr(stringf("(%s %s %s)", a.c_str(),
			       cell_type_translation[cell->type.str()].c_str(),
			       b.c_str()));
    if (a_signed) {
      out = mk_compatible(out, true, true, ow, aw);
      out = mk_unsigned(out);
      out = mk_compatible(out, bv, true, ow, ow);
    } else {
      out = mk_compatible(out, bv, true, ow, aw);
    }
    cell_cxt = bv;

  } else if (cell->type == "$shr" ||
	     cell->type == "$shl" ||
	     cell->type == "$sshr" ||
	     cell->type == "$sshl") {
    /* context determination size */
    std::string a = get_sig_expr_as_word(&cell->getPort("\\A"));
    std::string b = get_sig_expr_as_word(&cell->getPort("\\B"));
    int aw = cell->parameters.at("\\A_WIDTH").as_int();
    //int bw = cell->parameters.at("\\B_WIDTH").as_int();
    int ow = cell->parameters.at("\\Y_WIDTH").as_int();
    bool a_signed = cell->parameters.at("\\A_SIGNED").as_bool();
    bool b_signed = cell->parameters.at("\\B_SIGNED").as_bool(); 
    log_assert(!(b_signed));
    /* sign only comes into play if we are doing right arithmetic shift
       otherwise zeroes are padded on the right/left depending on the shift
    */
    if (cell->type == "$sshr" && a_signed) {
      a = mk_signed(a);
    }
    if (aw < ow) {
      a = mk_resize(a, ow);
      aw = ow;
    }
    out = sav_def_expr(stringf("(%s %s %s)", a.c_str(),
			       cell_type_translation[cell->type.str()].c_str(),
			       b.c_str()));
    if (cell->type == "$sshr" && a_signed) {
      out = mk_compatible(out, true, true, ow, aw);
      out = mk_unsigned(out);
      out = mk_compatible(out, bv, true, ow, ow);
    } else {
      out = mk_compatible(out, bv, true, ow, aw);
    }
    cell_cxt = bv;
      
  } 
  else if ( cell->type == "$shift" ||
            cell->type == "$shiftx") {
    /* context determination size */
    std::string a = get_sig_expr_as_word(&cell->getPort("\\A"));
    std::string b = get_sig_expr_as_word(&cell->getPort("\\B"));
    int aw = cell->parameters.at("\\A_WIDTH").as_int();
    //int bw = cell->parameters.at("\\B_WIDTH").as_int();
    int ow = cell->parameters.at("\\Y_WIDTH").as_int();
    bool a_signed = cell->parameters.at("\\A_SIGNED").as_bool();
    bool b_signed = cell->parameters.at("\\B_SIGNED").as_bool(); 
    // signed is not supported for now
    log_assert(!a_signed && !b_signed);
    if (aw < ow) {
      a = mk_resize(a, ow);
      aw = ow;
    }
    out = sav_def_expr(stringf("(%s %s %s)", a.c_str(),
			       cell_type_translation[cell->type.str()].c_str(),
			       b.c_str()));
    out = mk_compatible(out, bv, true, ow, aw);
    cell_cxt = bv;
  } 
  else if (cell->type == "$lt" ||
	     cell->type == "$le" ||
	     cell->type == "$eq" ||
	     cell->type == "$ne" ||
	     cell->type == "$eqx" ||
	     cell->type == "$nex" ||
	     cell->type == "$ge" ||
	     cell->type == "$gt") {
    /* self determined */
    std::string a = get_sig_expr_as_word(&cell->getPort("\\A"));
    std::string b = get_sig_expr_as_word(&cell->getPort("\\B"));
    bool a_signed = cell->parameters.at("\\A_SIGNED").as_bool();
    bool b_signed = cell->parameters.at("\\B_SIGNED").as_bool(); 
    log_assert(a_signed == b_signed);
    if (a_signed) {
      a = mk_signed(a);
      b = mk_signed(b);
    }
    int aw = cell->parameters.at("\\A_WIDTH").as_int();
    int bw = cell->parameters.at("\\B_WIDTH").as_int();
    int ow = cell->parameters.at("\\Y_WIDTH").as_int();
    if (aw < bw) {
      a = mk_resize(a, bw);
      aw = bw;
    }
    if (bw < aw) {
      b = mk_resize(b, aw);
      bw = aw;
    }
    out = sav_def_expr(stringf("(%s %s %s)", a.c_str(),
			       cell_type_translation[cell->type.str()].c_str(),
			       b.c_str()));
    out = mk_compatible(out, bv, false, ow, 1);
    cell_cxt = bv;

  } else if (cell->type == "$logic_and" ||
	     cell->type == "$logic_or") {
    /* self determined */
    std::string a = get_sig_expr_as_word(&cell->getPort("\\A"));
    std::string b = get_sig_expr_as_word(&cell->getPort("\\B"));
    int aw = cell->parameters.at("\\A_WIDTH").as_int();
    int bw = cell->parameters.at("\\B_WIDTH").as_int();
    int ow = cell->parameters.at("\\Y_WIDTH").as_int();
    //      log_assert(aw == bw);
    a = sav_def_expr(stringf("(%s %s 0ud%d_0)", a.c_str(),
			     cell_type_translation["$gt"].c_str(),
			     aw));
    b = sav_def_expr(stringf("(%s %s 0ud%d_0)", b.c_str(),
			     cell_type_translation["$gt"].c_str(),
			     bw));
    if (cell->type == "$logic_and") {
      out = sav_def_expr(stringf("(%s %s %s)", a.c_str(),
				 cell_type_translation["$and"].c_str(),
				 b.c_str()));
				   
    } else {
      out = sav_def_expr(stringf("(%s %s %s)", a.c_str(),
				 cell_type_translation["$or"].c_str(),
				 b.c_str())); 
    }
    out = mk_compatible(out, bv, false, ow, 1);
    cell_cxt = bv;

  } else if (cell->type == "$mux") {
    /* context determined , size is already corrected */
    std::string a = get_sig_expr_as_word(&cell->getPort("\\A"));
    std::string b = get_sig_expr_as_word(&cell->getPort("\\B"));
    std::string s = get_sig_expr_as_bool(&cell->getPort("\\S"));
    int ow = cell->parameters.at("\\WIDTH").as_int();
    out = sav_def_expr(stringf("(%s ? %s : %s)", 
			       s.c_str(), b.c_str(), a.c_str()));
    out = mk_compatible(out, bv, true, ow, ow);
    cell_cxt = bv;

  } else if (cell->type == "$pmux") {
    /* context determined, size is already corrected */
    std::string a = get_sig_expr_as_word(&cell->getPort("\\A"));
    std::string b = get_sig_expr_as_word(&cell->getPort("\\B"));
    std::string s = get_sig_expr_as_word(&cell->getPort("\\S"));
    int ow = cell->parameters.at("\\WIDTH").as_int();
    int sw = cell->parameters.at("\\S_WIDTH").as_int();
    out = string("(case\n");
    for (int i = 0; i < sw; ++i) {
      out += stringf("  bool(%s) : %s;\n", 
		     mk_slice(s, i, 1).c_str(), 
		     mk_slice(b, (i * ow + ow -1), ow).c_str());
    }
    out += stringf("  TRUE : %s;\n esac)", a.c_str());
    out = sav_def_expr(out);
    out = mk_compatible(out, bv, true, ow, ow);
    cell_cxt = bv;

  } else if (cell->type == "$memrd") {
    /* no need for size determination */
    if (cell->parameters.at("\\CLK_ENABLE").as_bool() == true)
      log_error("Run memory_dff -wr_only\n");
    std::string mem = cell->parameters.at("\\MEMID").decode_string();
    mem = stringf("\"%s\"",
		  RTLIL::unescape_id(module->memories.at(mem.c_str())->name).c_str());
    std::string a = get_sig_expr_as_word(&cell->getPort("\\ADDR"));
    out = sav_def_expr(stringf("READ(%s, %s)", mem.c_str(), a.c_str()));
    cell_cxt = true;

  } else if (cell->type == "$slice") {
    /* slice is actually selecting some bits, no need for size determination */
    std::string a = get_sig_expr_as_word(&cell->getPort("\\A"));
    int ow = cell->parameters.at("\\Y_WIDTH").as_int();
    int offset = cell->parameters.at("\\OFFSET").as_int();
    out = mk_slice(a, (ow + offset - 1), ow);
    log_assert(bv);
    cell_cxt = true;

  } else if (cell->type == "$concat") {
    /* no need for size determination in case of concat */
    std::string a = get_sig_expr_as_word(&cell->getPort("\\A"));
    std::string b = get_sig_expr_as_word(&cell->getPort("\\B"));
    int aw = cell->parameters.at("\\A_WIDTH").as_int();
    int bw = cell->parameters.at("\\B_WIDTH").as_int();
    int ow = cell->parameters.at("\\Y_WIDTH").as_int();
    out = mk_concat(a, b);
    out = mk_compatible(out, bv, true, ow, aw + bw);
    cell_cxt = bv;

  } else {
    log_error("Unsupported cell type : %s\n", cell->type.c_str());
  }

  ref.set(cell, out);
  cxt.set(cell, cell_cxt);
  return out;
}

void TranslateModule::mk_inter_wire_map()
{
  for (auto it = module->cells_.begin(); it != module->cells_.end(); ++it) {
    RTLIL::Cell *cell = it->second;
    const RTLIL::SigSpec* output_sig = get_cell_output(cell);

    if (output_sig==nullptr) {
      continue;
    }

    RTLIL::SigSpec s = sigmap(*output_sig);
    output_sig = &s;
 
    if (cell->type == "$memrd") {
      for (auto it = output_sig->chunks().begin();
	   it != output_sig->chunks().end();
	   ++it) {
	RTLIL::IdString wire_id = it->wire->name;
	inter_wire_map[wire_id].insert(WireInfo(cell->name, &(*it)));
      }
    } else if (cell->type == "$memwr" ||
	       cell->type == "$meminit") {
      continue;//nothing to do
    } else if (cell->type == "$dff" ||
	       cell->type == "$adff" ||
	       cell->type == "$dffsr" ||
	       cell->type == "$dlatch") {
      for (auto it = output_sig->chunks().begin();
	   it != output_sig->chunks().end();
	   ++it) {
	RTLIL::IdString wire_id = it->wire->name;
	inter_wire_map[wire_id].insert(WireInfo(cell->name, &(*it)));
      }
	
    } else {
      for (auto it = output_sig->chunks().begin();
	   it != output_sig->chunks().end();
	   ++it) {
	RTLIL::IdString wire_id = it->wire->name;
	inter_wire_map[wire_id].insert(WireInfo(cell->name, &(*it)));
      }
    }
  }
}

void TranslateModule::dump_ts_lst(std::vector<std::string> lst, std::string pre, std::string post)
{
  for (auto it = lst.begin(); it != lst.end(); ++it) {
    f << pre << it->c_str() << post;
  }
}

void TranslateModule::setup()
{ 
  mk_inter_wire_map();
}

// end of file
